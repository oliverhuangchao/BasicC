/* lab3.c
 * Xiang Ma    <--- replace with your name!
 * Xiang Ma          <--- replace with your user name
 * ECE 223 Fall 2014
 * MP2
 *
 * Version 2: fixed bugs related to INSERT
 *
 * NOTE:  You must replace all of the following comments!
 *
 * Purpose: A template for MP2 
 *
 * Assumptions: Many details are incomplete.  The functions to collect input
 * for a record and to print a record specify the format that is required for
 * grading.
 *
 * An outline for the interactive menu input is provided.  Details need to be
 * completed but format of the commands and the output generated by the
 * print statements should not be changed.  You have to call the corrent
 * print statement in response to the input
 *
 * Bugs: Many detail have not been implemented.
 *
 * See the ECE 223 programming guide
 *
 *
 * Are you unhappy with the way this code is formatted?  You can easily
 * reformat (and automatically indent) your code using the astyle 
 * command.  If it is not installed use the Ubuntu Software Center to 
 * install astyle.  Then in a terminal on the command line do
 *     astyle --style=kr lab1.c
 *
 * See "man astyle" for different styles.  Replace "kr" with one of
 * ansi, java, gnu, linux, or google to see different options.  Or, set up 
 * your own style.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <time.h>

#include "datatypes.h"
#include "list.h"
#include "soc_support.h"

#define MAXLINE 256

clock_t start, end;
double elapse_time; // milliseconds

int main(int argc, char *argv[])
{
    char line[MAXLINE];
    char command[MAXLINE];
    char junk[MAXLINE];
    int command_number;   // number found with command, either a
                          // list position or socket-id
    int num_items;
    int i;
    list_t *unsorted_list = NULL;  // Pointer to unsorted list
    list_t *sorted_list = NULL;  // Pointer to sorted list
    socket_t *rec_ptr = NULL; // Pointer to socket info

    if (argc != 2) {
        printf("Usage: ./lab3 sort_type\n");
        exit(1);
    }
    printf("Welcome to lab2.\n");

    sort_type = atoi(argv[1]);
    if (sort_type < 1 || sort_type > 5) {
        printf("lab3 has invalid list sort type: %d\n", sort_type);
        exit(2);

    sorted_list = soc_create();
    unsorted_list = soc_create();

    /* remember fgets includes newline \n unless line too long */
    while (fgets(line, MAXLINE, stdin) != NULL) {
        num_items = sscanf(line, "%s%d%s", command, &command_number, junk);
        if (num_items == 2 && strcmp(command, "insert") == 0) {
            //printf ("command number is: %d",command_number);
            rec_ptr = (socket_t *) malloc(sizeof(socket_t));
            soc_get_socket_id(rec_ptr);

            int added_return = -2;
            added_return = soc_unsorted_insert(unsorted_list, rec_ptr, command_number);

            if (added_return == 0) {
                printf("Inserted: %d into position %d\n", 
                        rec_ptr->socket_id, command_number);
            } else if (added_return == -1) {
                printf("Rejected: %d invalid position %d\n", 
                        rec_ptr->socket_id, command_number);
            } else {
                printf("Error with return value!  Your code must be fixed\n");
            }
            rec_ptr = NULL;

        } else if (num_items == 2 && strcmp(command, "replace") == 0) {
            rec_ptr = (socket_t *) malloc(sizeof(socket_t));
            soc_get_socket_id(rec_ptr);

            // for this command you must get the pointer to the old
            // record.  Call it old_rec_ptr
            socket_t *old_rec_ptr = NULL;

            old_rec_ptr = soc_unsorted_replace(unsorted_list, rec_ptr, command_number);

            if (old_rec_ptr == NULL) {
                printf("Did not replace: %d invalid position %d\n", 
                        rec_ptr->socket_id, command_number);
            } else {
                printf("Replaced: %d with %d into position %d\n", 
                        old_rec_ptr->socket_id, rec_ptr->socket_id, 
                        command_number);
                free(old_rec_ptr);
            }
            rec_ptr = NULL;
        } else if (num_items == 1 && strcmp(command, "pushback") == 0) {
            rec_ptr = (socket_t *) malloc(sizeof(socket_t));
            soc_get_socket_id(rec_ptr);
            soc_unsorted_insert(unsorted_list,rec_ptr,LISTPOS_TAIL);
            printf("Pushed: %d into position %d\n", rec_ptr->socket_id, 
                    soc_number_entries(unsorted_list) - 1);
            rec_ptr = NULL;

        } else if (num_items == 2 && strcmp(command, "erase") == 0) {
            rec_ptr = soc_unsorted_remove(unsorted_list,command_number);
            if (rec_ptr == NULL) {
                printf("Did not remove: invalid position %d\n", command_number);
            } else {
                printf("Erased: %d from position %d\n", rec_ptr->socket_id, 
                        command_number);
                free(rec_ptr);
            }
            rec_ptr = NULL;
        } else if (num_items == 1 && strcmp(command, "popback") == 0) {
            rec_ptr = soc_unsorted_remove(unsorted_list, LISTPOS_TAIL);
            if (rec_ptr == NULL) {
                printf("Did not pop: list is empty\n");
            } else {
                printf("Popped: %d from position %d\n", rec_ptr->socket_id, 
                    soc_number_entries(unsorted_list));
                free(rec_ptr);
            }
            rec_ptr = NULL;
        } else if (num_items == 2 && strcmp(command, "at") == 0) {
            rec_ptr = NULL;
            rec_ptr = soc_access(unsorted_list, command_number);
            if (rec_ptr == NULL) {
                printf("Did not print: invalid position %d\n", command_number);
            } else {
                printf("Record at position: %d\n", command_number);
                soc_print_socket_rec(rec_ptr);
            }
            rec_ptr = NULL;
        } else if (num_items == 1 && strcmp(command, "front") == 0) {
            rec_ptr = NULL;
            rec_ptr = soc_access(unsorted_list,LISTPOS_HEAD);
            if (rec_ptr == NULL) {
                printf("Did not print front: list is empty\n");
            } else {
                printf("Record at front:\n");
                soc_print_socket_rec(rec_ptr);
            }
            rec_ptr = NULL;
        } else if (num_items == 1 && strcmp(command, "back") == 0) {
            rec_ptr = NULL;
            rec_ptr = soc_access(unsorted_list, LISTPOS_TAIL);
            if (rec_ptr == NULL) {
                printf("Did not print back: list is empty\n");
            } else {
                printf("Record at back:\n");
                soc_print_socket_rec(rec_ptr);
            }
            rec_ptr = NULL;
        } else if (num_items == 2 && strcmp(command, "INSERT") == 0) {
            rec_ptr = (socket_t *) malloc(sizeof(socket_t));
            rec_ptr->socket_id = command_number;
            soc_fill_record(rec_ptr);
            soc_sorted_insert(sorted_list, rec_ptr);
            printf("Added to sorted list: %d\n", command_number);
            rec_ptr = NULL;
        } else if (num_items == 2 && strcmp(command, "LOOK") == 0) {
            rec_ptr = soc_sorted_lookup(sorted_list, command_number);
            if (rec_ptr == NULL) {
                printf("Did not find in sorted list: %d\n", command_number);
            } else {
                printf("Found in sorted list: %d\n", command_number);
                /* print other items in structure */
                soc_print_socket_rec(rec_ptr);
                assert(rec_ptr->socket_id == command_number);
            }
            rec_ptr = NULL;
        } else if (num_items == 2 && strcmp(command, "REMOVE") == 0) {
            rec_ptr = soc_sorted_remove(sorted_list, command_number);
            if (rec_ptr == NULL) {
                printf("Did not remove in sorted list: %d\n", command_number);
            } else {
                printf("Removed from sorted list: %d\n",command_number);
                soc_print_socket_rec(rec_ptr);
                assert(rec_ptr->socket_id == command_number);
                free(rec_ptr);
            }
            rec_ptr = NULL;
        } else if (num_items == 2 && strcmp(command, "UPDATE") == 0) {
            rec_ptr = (socket_t *) malloc(sizeof(socket_t));
            rec_ptr->socket_id = command_number;
            soc_fill_record(rec_ptr);
            socket_t *old_rec_ptr = soc_sorted_update(sorted_list, rec_ptr);
            if (old_rec_ptr == NULL) {
                printf("Did not update in sorted list: %d\n", command_number);
            } else {
                printf("Updated sorted list: %d, old record\n",command_number);
                soc_print_socket_rec(old_rec_ptr);
                assert(old_rec_ptr->socket_id == command_number);
                free(old_rec_ptr);
            }
            rec_ptr = NULL;
        } else if (num_items == 1 && strcmp(command, "print") == 0) {
            int num_in_list = soc_number_entries(unsorted_list );
            if (num_in_list == 0) {
                printf("Unsorted list empty\n");
            } else {
                printf("%d records in unsorted list\n", num_in_list);
                for (i = 0; i < num_in_list; i++) 
                {
                    printf("%d: ", i+1);
                    rec_ptr = soc_access(unsorted_list, i);
                    //rec_ptr = soc_sorted_lookup(unsorted_list , i);
                    // you must use this function to format output for a record
                    soc_print_socket_rec(rec_ptr);
                }
            }
        } else if (num_items == 1 && strcmp(command, "PRINT") == 0) {
            int num_in_list = soc_number_entries(sorted_list);
            if (num_in_list == 0) {
                printf("Sorted list empty\n");
            } else {
                printf("%d records in sorted list\n", num_in_list);
                for (i = 0; i < num_in_list; i++) {
                    printf("%d: ", i+1);
                    rec_ptr = soc_access(sorted_list, i);
                    // you must use this function to format output for a record
                    soc_print_socket_rec(rec_ptr);
                }
            }
        } else if (num_items == 1 && strcmp(command, "stats") == 0) {
            // get the number in list and size of the list
            int num_unsorted_list = soc_number_entries(unsorted_list);
            int num_sorted_list = soc_number_entries(sorted_list);
            printf("Unsorted number records: %d, Sorted number records: %d\n", 
                    num_unsorted_list, num_sorted_list);
        } else if (num_items == 1 && 
              (strcmp(command, "quit") == 0 || strcmp(command, "QUIT") == 0)) {
            printf("Goodbye\n");
            soc_cleanup(sorted_list);
            soc_cleanup(unsorted_list);
            break;
        } else if (num_items == 1 && strcmp(command, "SORT") == 0) {
            int initialsize = list_size(unsorted_list); 
            start = clock();        
            soc_sort(&unsorted_list, sort_type);
            end = clock(); 
            elapse_time =  1000.0 * ((double) (end - start)) / CLOCKS_PER_SEC;
            assert(list_size(unsorted_list) == initialsize); 
            printf("%d\t%f\t%d\n", initialsize, elapse_time, sort_type); 
        
        } else {
            printf("# %s", line);
        }
    }
    exit(0);
}

/* commands specified to vim. ts: tabstop, sts: soft tabstop sw: shiftwidth */
/* vi:set ts=8 sts=4 sw=4 et: */
